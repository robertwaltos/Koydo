import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const PROMPTS_DIR = path.resolve(__dirname, '../../GROK_Prompts/GROK_Media');
const OUTPUT_FILE = path.resolve(__dirname, '../src/lib/media/generated-prompts.ts');

console.log(`Compiling prompts from ${PROMPTS_DIR}...`);

if (!fs.existsSync(PROMPTS_DIR)) {
  console.error(`Error: Prompts directory not found at ${PROMPTS_DIR}`);
  process.exit(1);
}

const files = fs.readdirSync(PROMPTS_DIR).filter(f => f.endsWith('.md'));

const prompts = {};
let promptCount = 0;

files.forEach(file => {
  const content = fs.readFileSync(path.join(PROMPTS_DIR, file), 'utf-8');
  const category = file.replace('.md', '').toUpperCase();
  
  // Regex to find prompt blocks
  // Matches:
  // - **ID:** SOME_ID
  // ...
  // ```text
  // THE PROMPT
  // ```
  // OR just simple blocks if the structure varies.
  // Based on Voice.md and Animations.md, we look for `####? (Title)` then metadata list then code block.
  
  // Improved Regex strategy: Split by `## ` or `### ` headers?
  // Let's iterate through lines to be robust.
  
  const lines = content.split('\n');
  let currentId = null;
  let currentPrompt = [];
  let recordingPrompt = false;
  let currentMetadata = {};

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Check for ID
    const idMatch = line.match(/^\- \*\*ID:\*\* `?([A-Z0-9_]+)`?/);
    if (idMatch) {
      currentId = idMatch[1];
      currentMetadata = { category };
      currentPrompt = [];
      recordingPrompt = false;
    }

    // Check for Start of Code Block
    if (currentId && line.startsWith('```text') || line.startsWith('```')) {
        if (!recordingPrompt) {
            recordingPrompt = true;
            continue;
        }
    }

    // Check for End of Code Block
    if (recordingPrompt && (line.startsWith('```') && line.length === 3)) {
        recordingPrompt = false;
        if (currentId) {
            prompts[currentId] = {
                id: currentId,
                category: category,
                prompt: currentPrompt.join('\n').trim(),
                ...currentMetadata
            };
            promptCount++;
            currentId = null;
        }
    }

    if (recordingPrompt && !line.startsWith('```text')) {
        currentPrompt.push(lines[i]); // Keep original indentation? Yes.
    }
  }
});

const outputContent = `// This file is auto-generated by scripts/compile-media-prompts.mjs
// Do not edit manually.

export type MediaPrompt = {
  id: string;
  category: string;
  prompt: string;
  [key: string]: any;
};

export const MEDIA_PROMPTS: Record<string, MediaPrompt> = ${JSON.stringify(prompts, null, 2)};

export function getPrompt(id: string): string | undefined {
  return MEDIA_PROMPTS[id]?.prompt;
}

export function getPromptsByCategory(category: string): MediaPrompt[] {
  return Object.values(MEDIA_PROMPTS).filter(p => p.category === category);
}
`;

fs.writeFileSync(OUTPUT_FILE, outputContent);
console.log(`Successfully compiled ${promptCount} prompts to ${OUTPUT_FILE}`);
